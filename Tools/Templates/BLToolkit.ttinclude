<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#
	AppDomain.CurrentDomain.AssemblyResolve += (_,args) => System.Reflection.Assembly.LoadFile(DataProviderAssembly);
#><#+
string ConnectionString;
string ConnectionType;
string DataProviderAssembly = null;

string DataContextName;
string Namespace = "DataModel";
string BaseClass = "DbManager";

bool   IsMetadataLoaded;

static Action<GeneratedTextTransformation,Table> RenderTable = (tt,t) =>
{
	RenderTableAttributes(tt, t);

	tt.WriteLine("public partial class {0}", t.ClassName);
	tt.WriteLine("{");
	tt.PushIndent("\t");

	foreach (var c in t.Columns)
	{
		tt.WriteLine("public int {0};", c.ColumnName);
	}

	tt.PopIndent();
	tt.WriteLine("}");
};

static Action<GeneratedTextTransformation,Table> RenderTableAttributes = (tt,t) =>
{
	tt.Write("[TableName(");
	
	if (!string.IsNullOrEmpty(t.Owner))
		tt.Write("Owner=\"{0}\", ", t.Owner);

	tt.WriteLine("Name=\"{0}\")]", t.TableName);
};

void GenerateModel()
{
	if (ConnectionString != null) ConnectionString = ConnectionString.Trim();
	if (DataContextName  != null) DataContextName  = DataContextName. Trim();

	if (string.IsNullOrEmpty(ConnectionString)) { Error("ConnectionString cannot be empty."); return; }
	if (string.IsNullOrEmpty(DataContextName))  { Error("DataContextName cannot be empty.");  return; }

	LoadMetadata();
#>
//--------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by BLToolkit template for T4.
//
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//--------------------------------------------------------------------------------------------------
using System;

using BLToolkit.Data;
using BLToolkit.Data.Linq;
using BLToolkit.DataAccess;

namespace <#= Namespace #>
{
	public partial class <#= DataContextName #> : <#= BaseClass #>
	{
<#+
	var tlist  = (from t in Tables.Values orderby t.TableName select t).ToList();
	var maxlen = tlist.Max(_ => _.ClassName.Length);

	foreach (var t in tlist)
	{
#>
		public Table<<#= t.ClassName #>> <#=
			LenDiff(maxlen, t.ClassName) + t.ClassName + LenDiff(maxlen, t.ClassName) #> { get { return GetTable<<#= 
			t.ClassName #>>(); <#= 
			LenDiff(maxlen, t.ClassName) #>} }
<#+
	}
#>
	}
<#+
	foreach (var t in tlist)
	{
		WriteLine("");
		PushIndent("\t");
		RenderTable(this, t);
		PopIndent();
	}
#>
}
<#+
}

string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

List<T> CreateList<T>(T item)
{
	return new List<T>();
}

System.Data.IDbConnection GetConnection()
{
	var connType = Type.GetType(ConnectionType);
	var conn     = (System.Data.IDbConnection)Activator.CreateInstance(connType);

	conn.ConnectionString = ConnectionString;
	conn.Open();

	return conn;
}

Dictionary<string,Table> Tables = new Dictionary<string,Table>();

class Table
{
	public string Owner;
	public string TableName;
	public string ClassName;
	public bool   isView;

	public List<Column> Columns = new List<Column>();
}

class Column
{
	public string ColumnName;
	public string MemberName;
	public bool   IsNullable;
	public bool   IsIdentity;
}
#>
