<%@ Page language="c#" Codebehind="Default.aspx.cs" AutoEventWireup="false" Inherits="WebRFD._Default" %>
<%@ Register TagPrefix="uc1" TagName="Header" Src="Header.ascx" %>
<%@ Register TagPrefix="uc1" TagName="Footer" Src="Footer.ascx" %>
<%@ Register TagPrefix="uc1" TagName="Menu" Src="Menu.ascx" %>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
<HEAD>
<title>The Rsdn.Framework.Data namespace</title>
<meta content=http://schemas.microsoft.com/intellisense/ie5 name=vs_targetSchema>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name="keywords" content="orm, object relational mapping, object-relational mapping, high performance, object, relational, mapping, performance, ADO, design, development, database, shareware, freeware, public domain, free, web, news, custom design, forum, forums, yahoo, software, Java, SQL, Access, SQL Server, VB.NET, C++, J#, C#, ADO.NET, .NET">
<meta name="description" content="Rsdn.Framework.Data is a namespace that represents a higher-level wrapper for ADO.NET with high performance object-relational mapping.">
<LINK href="rfd.css" type=text/css rel=stylesheet>
  </HEAD>
<body marginheight="0" marginwidth="0">
<TABLE height="100%" cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TR>
    <TD class=hdr colSpan=2><uc1:header id=Header1 runat="server"></uc1:header></TD></TR>
  <TR>
    <TD class=menu vAlign=top><uc1:menu id=Menu1 runat="server"></uc1:menu></TD>
    <TD class=art vAlign=top width="100%" height="100%"><font size=2>
<!------ Article Starts ----->

<H2>The Rsdn.Framework.Data namespace</H2>

<p><CENTER>
<IMG src="http://www.rsdn.ru/article/files/libs/RsdnFrameworkData/RsdnFrameworkData.gif" title="">
</CENTER>
      <P></P>

<P><b>Rsdn.Framework.Data</b> is a namespace that represents a higher-level wrapper for ADO.NET 
with high performance object-relational mapping.<br>
The following features are implemented by the namespace:</P>

<UL>
<LI><b>Support for different data providers.</b><br>
The namespace manipulates the ADO.NET interfaces only. It does not use any data provider directly, 
instead it communicates with the simple <i>IDataProvider</i> interface, which can be easily used 
to extend the list of supported data providers.

<LI><b>Returning <i>IDataReader</i>, <i>DataTable</i>, <i>DataSet</i>, business entity objects, or single values.</b><br>
Obviously the namespace supports all standard ways to obtain data, adds some new methods to get 
<i>DataTable</i>, and simplifies working with your business objects.

<LI><b>Returning a list of business entity objects.</b><br>
You can get a list of business objects as easy as you read <i>DataSet</i> using the 
<i>Fill</i> method of the <i>SqlDataAdapter</i> class.

<LI><b>High performance object-relational mapping.</b><br>
The library is optimized for high performance data mapping. The <i>System.Reflection</i> namespace is used 
to prepare initial type information, and then custom classes are generated by the 
<i>System.Reflection.Emit</i> namespace classes. This allows to avoid slowness of the reflection 
and gain incredible performance.
</LI>
</UL>

<H3>Version 1.1 Fixes and Features<a name="v11"></a></H3>
<H4>Features</H4>

<ul>
<li>New <i>DbManager.ExecuteDictionary</i> method.<br>
The method executes a query and returns the <i>Hashtable</i> of business entities.
<li>New <i>MapData.MapDictionary</i> method.<br>
The method maps data from/to Hashtable or an object that implements the IDictionary interface.
<li>Support for <i>IDataReader</i> interface.<br>
New overloaded versions of the <i>MapData.MapList</i> and <i>MapData.MapDictionary</i> methods 
added to support mapping from/to the <i>IDataReader</i>.
<li>Enhancement of the <i>MapValueAttribute</i> attribute.<br>
Now the attribute can be applied directly to enumeration values:
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">enum</SPAN> Status
{
    [MapValue(<SPAN class="STRING">"A"</SPAN>)] Active,
    [MapValue(<SPAN class="STRING">"I"</SPAN>)] Inactive,
    [MapValue(<SPAN class="STRING">"P"</SPAN>)] Pending
}</font></PRE></TD></TR></TABLE></p>
<P>This is only way to define the attributes in Managed C++.</P>
<li>New <i>RsdnDbManagerException</i> and <i>RsdnMapDataException</i> classes.<br>
All exceptions thrown by the library or used classes are wrapped in these exception classes and returned 
as inners.
</li></ul>

<h4>Fixes</h4>
<ul><li>An exception occurs when attempting to add the <i>DbManager</i> to a form.</li></ul>

<h3>Version 1.2 Fixes and Features<a name="v12"></a></h3>
<h4>Features</h4>

<ul>

<li>The <i>MapData</i> class has been moved to the <i>Rsdn.Framework.Data.Mapping</i> namespace and 
renamed to <i>Map</i>

<li>Support for abstract classes added.<br>
Now it's possible to skip implementation of class properties and define read-only class members.
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">abstract</SPAN> <SPAN class="KEYWORD">class</SPAN> MyBizEntity
{
    <SPAN class="KEYWORD">public abstract int</SPAN>    ID          { get; }
    <SPAN class="KEYWORD">public abstract string</SPAN> Description { get; set; }
}</font></PRE></TD></TR></TABLE></p>

<li>New <b>MapTypeAttribute</b> attribute.
<li>New <b>MapParameterAttribute</b> attribute.
<li>New <b>MapIgnoreAttribute</b> attribute.
<li>New <b>MapDescriptor</b> class.
<li>New <b>IMapObjectFactory</b> interface.
<li>Enhancement of the <i>MapFieldAttribute</i> attribute use.
<li>Support for nullable types added.
<li>Support for the <i>Guid</i> type added.
<li>Xml schema mapping added.<br>
The <i>SetMappingSchema</i> method can be used to assign default mapping schema.
<li>New <b>MapXmlAttribute</b> attribute.
</li></ul>

<h4>Fixes</h4>

<ul><li>Couple of minor bugs has been fixed.</li></ul>

<P>
The major changes of this version apply to mapping features. 
The <i>MapData</i> class was renamed and moved to the <i>Rsdn.Framework.Data.Mapping</i> namespace.
Some methods of the class were renamed as well. 
Old names are decorated with the <i>Obsolete</i> attribute and will be removed with the next version 
of the library.
</P>

<h4>Abstract classes</h4>

<P>
Support for abstract classes allows to get actually declarative business object definition and 
to skip implementation of properties. 
The following example demonstrates typical business object definition:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public class</SPAN> MyBizEntity
{
    <SPAN class="KEYWORD">private int</SPAN> _id;
    <SPAN class="KEYWORD">public  int</SPAN>  ID
    {
        <SPAN class="KEYWORD">get</SPAN> { <SPAN class="KEYWORD">return</SPAN> _id;  }
        <SPAN class="KEYWORD">set</SPAN> { _id = value; }
    }

    <SPAN class="KEYWORD">private string</SPAN> _description;
    <SPAN class="KEYWORD">public  string</SPAN>  Description
    {
        <SPAN class="KEYWORD">get</SPAN> { <SPAN class="KEYWORD">return</SPAN> _description;  }
        <SPAN class="KEYWORD">set</SPAN> { _description = value; }
    }
}</font></PRE></TD></TR></TABLE></p>

<p>Abstract definition looks like the following:</p>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public abstract class</SPAN> MyBizEntity
{
    <SPAN class="KEYWORD">public abstract int</SPAN>    ID          { get; }
    <SPAN class="KEYWORD">public abstract string</SPAN> Description { get; set; }
}</font></PRE></TD></TR></TABLE></p>

<P>This way is a little bit shorter and allows to define read-only class properties.</P>

<h4>MapTypeAttribute</h4>

<P>If one of the abstract properties has to be implemented by different from return value type, 
the <i>MapTypeAttribute</i> attribute can be used. 
Suppose we have internal property implementation using the following class: </P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public class</SPAN> MyString
{
    <SPAN class="KEYWORD">private string</SPAN> _value;
    <SPAN class="KEYWORD">public  string</SPAN>  Value
    {
        <SPAN class="KEYWORD">get</SPAN> { <SPAN class="KEYWORD">return</SPAN> _value;  }
        <SPAN class="KEYWORD">set</SPAN> { _value = value; }
    }
}</font></PRE></TD></TR></TABLE></p>

<P>Typical property definition could be the following:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public class</SPAN> MyBizEntity
{
    <SPAN class="KEYWORD">private</SPAN> MyString _description;
    <SPAN class="KEYWORD">public</SPAN>  <SPAN class="KEYWORD">string</SPAN>    Description
    {
        <SPAN class="KEYWORD">get</SPAN> { <SPAN class="KEYWORD">return</SPAN> _description.Value;  }
        <SPAN class="KEYWORD">set</SPAN> { _description.Value = value; }
    }
}</font></PRE></TD></TR></TABLE></p>

<P>Abstract property definition: </P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public abstract class</SPAN> MyBizEntity
{
    [MapType(<SPAN class="KEYWORD">typeof</SPAN>(MyString))]
    <SPAN class="KEYWORD">public abstract string</SPAN> Description { get; set; }
}</font></PRE></TD></TR></TABLE></p>

<P>
In this case the mapper expects that <i>MyString</i> has <i>Value</i> property and the 'Value' property type 
is coincident with the 'Description' property return value type.
</P>

<h4>MapIgnoreAttribute</h4>

<P>This attribute excludes a class member from the mapping. </P>

<h4>MapDescriptor</h4>

<P>
The <i>MapDescriptor</i> class represents a mapped type descriptor. 
It consists of methods that can be used to create business objects and to access object members. 
The following example demonstrates how to create an instance of the <i>MyBizEntity</i> class and 
to assign a value to its read-only property <i>ID</i>:
</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>MapDescriptor desc   = MapDescriptor.GetDescriptor(<SPAN class="KEYWORD">typeof</SPAN>(MyBizEntity));
MyBizEntity   entity = desc.CreateInstance() <SPAN class="KEYWORD">as</SPAN> MyBizEntity;

Desc[<SPAN class="STRING">"ID"</SPAN>].SetValue(entity, 1);</font></PRE></TD></TR></TABLE></p>

<P>
Actually, this way is not designed for daily use. 
Hovever, it can be useful as a "back door" to develop various frameworks.
</P>

<h4>IMapObjectFactory</h4>

<P>This interface allows to control the business object creation process.</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public</SPAN> MyBizEntityManager : IMapObjectFactory
{
    <SPAN class="KEYWORD">private</SPAN> MapDescriptor _descriptor;

    <SPAN class="KEYWORD">public</SPAN> MyBizEntityManager()
    {
        _descriptor = MapDescriptor.getDescriptor(<SPAN class="KEYWORD">typeof</SPAN>(MyBizEntity));
        _descriptor.ObjectFactory = <SPAN class="KEYWORD">this</SPAN>;
    }

    <SPAN class="KEYWORD">object</SPAN> IMapObjectFactory.CreateInstance(
        IMapDataSource dataSource,
        <SPAN class="KEYWORD">object</SPAN>         sourceObject,
        <SPAN class="KEYWORD">object</SPAN>[]       parameters,
        <SPAN class="KEYWORD">ref</SPAN> <SPAN class="KEYWORD">bool</SPAN>       stopMapping)
    {
        <SPAN class="KEYWORD">return</SPAN> _descriptor.CreateInstance(
            dataSource, sourceObject, parameters, stopMapping);
    }
}</font></PRE></TD></TR></TABLE></p>

<P>As you see, the object is created by using type descriptor. However, it's not required.</P>

<h4>MapFieldAttribute</h4>

<P>Now this attribute can be applied to a class itself. 
In this case, it specifies additional naming of source and target objects that can not be done in 
normal way.</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public class</SPAN> BaseBizEntity
{
    <SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">int</SPAN> ID;
}

[MapField(SourceName=<SPAN class="STRING">"OrderID"</SPAN>, TargetName=<SPAN class="STRING">"ID"</SPAN>)]
<SPAN class="KEYWORD">public class</SPAN> Order : BaseBizEntity
{
    <SPAN class="KEYWORD">public int</SPAN> Number;
}

[MapField(<SPAN class="STRING">"CustomerID"</SPAN>, <SPAN class="STRING">"ID"</SPAN>)]
[MapField(<SPAN class="STRING">"OrderID"</SPAN>,    <SPAN class="STRING">"Order.ID"</SPAN>)]
<SPAN class="KEYWORD">public class</SPAN> Customer : BaseBizEntity
{
    <SPAN class="KEYWORD">public string</SPAN> Name;
    <SPAN class="KEYWORD">public</SPAN> Order  Order = <SPAN class="KEYWORD">new</SPAN> Order();
}</font></PRE></TD></TR></TABLE></p>

<h4>Nullable values</h4>

<P>Now the mapper supports nullable types such as System.Data.SqlTypes and its analogues.</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public abstract class</SPAN> MyBizEntity
{
    <SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">abstract</SPAN> SqlString Description { get; set; }
}</font></PRE></TD></TR></TABLE></p>

<P>The mapper expects the presence of the <i>Value</i> and <i>IsNull</i> properties of these types.</P>

<h4>Guid</h4>

<P>Support for the Guid type added.</P>

<h4>Xml mapping schemas</h4>

<P>Generally, xml mapping schema looks like the following:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>&lt;?xml version=<SPAN class="STRING">"1.0"</SPAN> encoding=<SPAN class="STRING">"utf-8"</SPAN> ?&gt;
&lt;mapping xmlns=<SPAN class="STRING">"http://www.rsdn.ru/mapping.xsd"</SPAN>&gt;
    &lt;type name=<SPAN class="STRING">"NamespaceName.TypeName"</SPAN>&gt;
        &lt;field name=<SPAN class="STRING">"field1"</SPAN> source=<SPAN class="STRING">"field1"</SPAN> trimmable=<SPAN class="STRING">"true"</SPAN> /&gt;
        &lt;field name=<SPAN class="STRING">"field2"</SPAN>&gt;
            &lt;value target=<SPAN class="STRING">"3"</SPAN> source=<SPAN class="STRING">"2"</SPAN> source_type=<SPAN class="STRING">"System.Int32"</SPAN> /&gt;
        &lt;/field&gt;
        &lt;field name=<SPAN class="STRING">"field3"</SPAN> nullable=<SPAN class="STRING">"true"</SPAN>&gt;
            &lt;value target=<SPAN class="STRING">"3"</SPAN> source=<SPAN class="STRING">"2"</SPAN> source_type=<SPAN class="STRING">"System.Int32"</SPAN> /&gt;
            &lt;null_value target=<SPAN class="STRING">"111"</SPAN>/&gt;
        &lt;/field&gt;
        &lt;field name=<SPAN class="STRING">"field4"</SPAN> ignore=<SPAN class="STRING">"true"</SPAN> /&gt;
    &lt;/type&gt;
    &lt;value_type name=<SPAN class="STRING">"NamespaceName.ValueTypeName "</SPAN>&gt;
        &lt;value target=<SPAN class="STRING">"Active"</SPAN>   source=<SPAN class="STRING">"A"</SPAN> source_type=<SPAN class="STRING">"System.String"</SPAN> /&gt;
        &lt;value target=<SPAN class="STRING">"Inactive"</SPAN> source=<SPAN class="STRING">"I"</SPAN> source_type=<SPAN class="STRING">"System.String"</SPAN> /&gt;
        &lt;value target=<SPAN class="STRING">"Pending"</SPAN>  source=<SPAN class="STRING">"P"</SPAN> source_type=<SPAN class="STRING">"System.String"</SPAN> /&gt;
        &lt;null_value target=<SPAN class="STRING">"Unknown"</SPAN>/&gt;
    &lt;/value_type&gt;
&lt;/mapping&gt;</font></PRE></TD></TR></TABLE></p>

<P>
The type tag defines mapping schema of the particular type. 
The <i>value_type</i> tag is used to define mapping for enumerators. 
The <i>SetMappingSchema</i> overrides register a default xml mapping schema. 
The <i>SetMappingSchema(string)</i> method performs a search of schema file for provided name. 
If the file is not found, the method tries to find it in the calling assembly resources. 
If the type has mapping attribute, the xml schema has a higher priority. For example:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>&lt;?xml version=<SPAN class="STRING">"1.0"</SPAN> encoding=<SPAN class="STRING">"utf-8"</SPAN> ?&gt;
&lt;mapping xmlns=<SPAN class="STRING">"http://www.rsdn.ru/mapping.xsd"</SPAN>&gt;
    &lt;type name=<SPAN class="STRING">"NamespaceName.Dest"</SPAN>&gt;
        &lt;field name=<SPAN class="STRING">"Field1"</SPAN>&gt;
            &lt;null_value target=<SPAN class="STRING">"-1"</SPAN> /&gt;
        &lt;/field&gt;
    &lt;/type&gt;
&lt;/mapping&gt;</font></PRE></TD></TR></TABLE></p>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">public class</SPAN> Src
{
    <SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">object</SPAN> Field1 = <SPAN class="KEYWORD">null</SPAN>;
    <SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">object</SPAN> Field2 = <SPAN class="KEYWORD">null</SPAN>;
}

<SPAN class="KEYWORD">public</SPAN> <SPAN class="KEYWORD">class</SPAN> Dest
{
    [MapNullValue(-2)]
    <SPAN class="KEYWORD">public int</SPAN> Field1;

    [MapNullValue(-3)]
    <SPAN class="KEYWORD">public int</SPAN> Field2;
}

<SPAN class="KEYWORD">void</SPAN> Test()
{
    MapDescriptor.SetMappingSchema(<SPAN class="STRING">"Map.xml"</SPAN>);

    Src  s = <SPAN class="KEYWORD">new</SPAN> Src();
    Dest d = Map.ToObject(s, <SPAN class="KEYWORD">typeof</SPAN>(Dest)) <SPAN class="KEYWORD">as</SPAN> Dest;

    <SPAN class="COMMENT">// d.Field1 == -1</SPAN>
    <SPAN class="COMMENT">// d.Field2 == -3</SPAN>
}</font></PRE></TD></TR></TABLE></p>

<P>
During the test execution, xml schema is used to assign <i>Field1</i> field value.
<i>Field2</i> is assigned from the attribute.
</P>

<h4>MapXmlAttribute</h4>

<P>This attribute specifies xml file name and path to type definition. For example:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>&lt;?xml version=<SPAN class="STRING">"1.0"</SPAN> encoding=<SPAN class="STRING">"utf-8"</SPAN> ?&gt;
&lt;mapping xmlns=<SPAN class="STRING">"http://www.rsdn.ru/mapping.xsd"</SPAN>&gt;
    &lt;type name=<SPAN class="STRING">"MyBizEntity"</SPAN>&gt;
        ...
    &lt;/type&gt;
&lt;/mapping&gt;</font></PRE></TD></TR></TABLE></p>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>[MapXml(<SPAN class="STRING">"MyMapping.xml"</SPAN>, <SPAN class="STRING">"MyBizEntity"</SPAN>)]
<SPAN class="KEYWORD">public class</SPAN> MyBizEntity
{
    <SPAN class="COMMENT">// ...</SPAN>
}</font></PRE></TD></TR></TABLE></p>

<P>If xml schema is set by <i>SetMappingSchema</i> method, single attribute parameter can be used:</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>[MapXml(<SPAN class="STRING">"MyBizEntity"</span>)]
<SPAN class="KEYWORD">public class</SPAN> MyBizEntity
{
    <SPAN class="COMMENT">// ...</SPAN>
}</font></PRE></TD></TR></TABLE></p>


<h3>Version 1.3 Fixes and Features<a name="v13"></a></h3>
<h4>Features</h4>

<ul>

<li>New <b>SetCommand</b> and <b>SetSpCommand</b> methods.
<li>New <b>Update</b> method.
<li>Enhancement of the <b>MapTypeAttribute</b> attribute.
<li>Support for the <b>ISupportInitialize</b> attribute added.
<li>New <b>IMapSettable</b> interface.
</ul>

<h4>Fixes</h4>

<ul><li>Not this time.</li></ul>

<h4>SetCommand, SetSpCommand</h4>

<p>
The major changes of this release apply to the <i>DbManager</i> class. 
Parameters that are responsible for the creation of the command have been removed from the 
<i>Execute*</i> methods. So, if <i>ExecuteScalar</i> method call looked like the following:
</p>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">using</span> (DbManager db = <SPAN class="KEYWORD">new</span> DbManager())
{
    <SPAN class="KEYWORD">return</span> (<SPAN class="KEYWORD">int</span>)db.ExecuteScalar(<SPAN class="STRING">"SELECT Count(*) FROM Categories"</span>);
}</font></PRE></TD></TR></TABLE></p>

<p>now it has to go after SetCommand or SetSpCommand method call:</p>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">using</span> (DbManager db = <SPAN class="KEYWORD">new</span> DbManager())
{
    <SPAN class="KEYWORD">return</span> (<SPAN class="KEYWORD">int</span>)db
        .SetCommand(<SPAN class="STRING">"SELECT Count(*) FROM Categories"</span>)
        .ExecuteScalar();
}</font></PRE></TD></TR></TABLE></p>

<p>Old methods are decorated with the Obsolete attribute and will be removed with the next version of the library.</p>


<h4>Update</h4>

<p>
Method <i>Update</i> represents a wrapper for the <i>DbDataAdapter.Update</i> method.
Methods <i>SetInsertCommand</i>, <i>SetUpdateCommand</i>, <i>SetDeleteCommand</i> are used 
to assign the insert, update, and delete commands.
</p>
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><span class="KEYWORD">using</span> (DbManager db = <span class="KEYWORD">new</span> DbManager())
{
    db
        .SetInsertCommand(<span class="STRING">"INSERT statement"</span>)
        .SetUpdateCommand(<span class="STRING">"UPDATE statement"</span>)
        .SetDeleteCommand(<span class="STRING">"DELETE statement"</span>)
        .Update(dataSet);
}</font></PRE></TD></TR></TABLE></p>

<h4>MapTypeAttribute</h4>

<p>
The attribute acquired set of parameters that could be passed to a constructor of the 
implementing an abstract property class. For example:
</p>
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><span class="KEYWORD">public abstract class</span> MyBizEntity : BizEntityBase
{
    [MapType(<span class="KEYWORD">typeof</span>(RequiredString), <span class="STRING">"Description"</span>, 20)]
    <span class="KEYWORD">public abstract string</span> Description { <span class="KEYWORD">get</span>; <span class="KEYWORD">set</span>; }
}</font></PRE></TD></TR></TABLE></p>
<p>
See an example of the attribute use in the documentation.
</p>

<h4>ISupportInitialize</h4>

<p>
If the class being mapped implements interface <i>ISupportInitialize</i>, 
the mapper calls method <i>BeginInit</i> before and <i>EndInit</i> after the mapping.
</p>
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><span class="KEYWORD">public class</span> InitializedEntity : ISupportInitialize
{
    <span class="KEYWORD">private bool</span> _isBeingMapped;

    <span class="KEYWORD">void</span> ISupportInitialize.BeginInit()
    {
        _isBeingMapped = <span class="KEYWORD">true</span>;
    }

    <span class="KEYWORD">void</span> ISupportInitialize.EndInit()
    {
        _isBeingMapped = <span class="KEYWORD">false</span>;
    }
}</font></PRE></TD></TR></TABLE></p>

<h4>IMapSettable</h4>

<p>
This interface includes method <i>SetField</i>. During the mapping, 
source fields are passed to this method one by one. 
If the object handles a field by itself, this method has to return true. 
Otherwise the mapper will try to map the field. 
The following example shows how to use the interface to implement property <i>ID</i> 
of the base business object class:
</p>
<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><span class="KEYWORD">public abstract class</span> BizEntityBase : IMapSettable
{
    <span class="KEYWORD">private</span> Guid _id;
    <span class="KEYWORD">public</span>  Guid  ID { <span class="KEYWORD">get</span> { <span class="KEYWORD">return</span> _id; } }

    <span class="KEYWORD">bool</span> IMapSettable.SetField(<span class="KEYWORD">string</span> fieldName, <span class="KEYWORD">object</span> value)
    {
        <span class="KEYWORD">if</span> (<span class="KEYWORD">string</span>(fieldName, GetType().Name + <span class="STRING">"ID"</span>) == 0)
        {
            _id = (Guid)value;

            <span class="KEYWORD">return true</span>;
        }

        <span class="KEYWORD">return false</span>;
    }
}</font></PRE></TD></TR></TABLE></p>

<h3>Known Problems<a name="np"></a></h3>

<ul>

<li>
<P>
During the abstract class mapping the mapper creates a derived class that implements abstract properties.
Obviously, the full name of the class is different from the original name. 
Name of the generated class is the following:
</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>NamespaceName.<i>AbstractClassName</i>.MappingExtension.<i>AbstractClassName</i></font></PRE></TD></TR></TABLE></p>

<P>
So, the <i>GetType().Name</i> property returns the same name for the original and derived classes. 
The <i>GetType().FullName</i> method returns different ones. Also direct type comparison does not work correctly.
</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2>MyBizEntity entity = MapDescriptor.GetDescriptor
    (<SPAN class="KEYWORD">typeof</SPAN>(MyBizEntity)).CreateInstanceEx();

<SPAN class="KEYWORD">if</SPAN> (entity.GetType() == <SPAN class="KEYWORD">typeof</SPAN>(MyBizEntity)) {}  <SPAN class="COMMENT">// false</SPAN>
<SPAN class="KEYWORD">if</SPAN> (entity <SPAN class="KEYWORD">is</SPAN> MyBizEntity) {}                    <SPAN class="COMMENT">// true</SPAN></font></PRE></TD></TR></TABLE></p>

<li>
<P>
As dynamic assemblies are generated in memory, they don't implement some methods and throw the 
<i>NonImplementedException</i> when the methods are addressed. 
This issue can be solved by the explicit assembly type check.
</P>

<p><TABLE class="code" width="96%"><TR><TD><PRE><font size=2><SPAN class="KEYWORD">foreach</SPAN> (Assembly a <SPAN class="KEYWORD">in</SPAN> AppDomain.CurrentDomain.GetAssemblies())
{
    <SPAN class="KEYWORD">if</SPAN> (a <SPAN class="KEYWORD">is</SPAN> System.Reflection.Emit.AssemblyBuilder)
        <SPAN class="KEYWORD">continue</SPAN>;

    Console.WriteLine(a.CodeBase);
}</font></PRE></TD></TR></TABLE></p>
</li>

</ul>



<!------ Article Ends ----->
</font>
</TD></TR>
			<TR>
				<TD class="ftr" colspan="2"><uc1:Footer runat="server" id=Footer1></uc1:Footer></TD>
			</TR></TABLE>
	</body>
</HTML>