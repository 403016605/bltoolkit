<!-- HTML for article "The Rsdn.Framework.Data namespace" by Igor Tkachev,Igor Tkachev,Igor Tkachev
     URL: http://www.codeproject.com/dotnet/RsdnFrameworkData.asp

     Article content copyright Igor Tkachev,Igor Tkachev,Igor Tkachev
     All formatting, additions and alterations Copyright © CodeProject, 2003
-->
<!----------------------------- Ignore ----------------------------->
<link rel="stylesheet" type=text/css href="http://www.codeproject.com/styles/global.css">
<p><b>Please choose 'View Source' in your browser to view the HTML, or  
File | Save to save this file to your hard drive for editing.</b></p>
<hr size=1 noshade>
<!----------------------------- Ignore ----------------------------->


<!----------------------------- Article Starts ----------------------------->

<UL class=download>
<LI><A href="http://www.codeproject.com/dotnet/RsdnFrameworkData/RsdnFrameworkData.zip">Download setup - 193 Kb</A> </LI></UL>
<P><IMG height=347 alt="Sample Image - RsdnFrameworkData.gif" src="http://www.codeproject.com/dotnet/RsdnFrameworkData/RsdnFrameworkData.gif" width=350></P>
<H2>Introduction</H2>
<P>The <CODE lang=cs>Rsdn.Framework.Data</CODE> is a namespace that represents a higher-level wrapper for ADO.NET.</P>
<P>The following features are implemented by the namespace:</P>
<UL>
<LI>Support for different data providers. 
<P>The namespace manipulates the ADO.NET interfaces only. It does not use any data provider directly, instead it communicates with the simple <CODE lang=cs>IDataProvider</CODE> interface, which can be easily used to extend the list of supported data providers. </P>
<LI>Returning <CODE lang=cs>IDataReader</CODE>, <CODE lang=cs>DataTable</CODE>, <CODE lang=cs>DataSet</CODE>, business entity objects, or single values. 
<P>Obviously the namespace supports all standard ways to obtain data, adds some new methods to get <CODE lang=cs>DataTable</CODE>, and simplifies working with your business objects. </P>
<LI>Returning a list of business entity objects. 
<P>You can get a list of business objects as easy as you read <CODE lang=cs>DataSet</CODE> using the <CODE lang=cs>Fill</CODE> method of the <CODE lang=cs>SqlDataAdapter</CODE> class.</P>
<LI>High performance relational data mapping to business entities. 
<P>The library is optimized for high performance data mapping. The <CODE lang=cs>System.Reflection</CODE> namespace is used to prepare initial type information, and then custom classes are generated by the <CODE lang=cs>System.Reflection.Emit</CODE> namespace classes. This allows to avoid slowness of the reflection and gain incredible performance :o) </P></LI></UL>
<H2>Examples</H2>
<P>I won’t make you bored by providing you with the complete list of the library functions and features here. You can find them in the documentation. Instead let’s take a look at a few examples that give you some idea of what the library is and how it can be used.</P>
<OL>
<LI>Basic example, just an introduction <PRE lang=cs>using System; 

using Rsdn.Framework.Data;

namespace Example
{
    class Test
    {
        static void Main()
        {
            using (DbManager db = new DbManager())
            {
                string name = (string)db.ExecuteScalar(@"
                    SELECT
                        CategoryName
                    FROM  Categories 
                    WHERE CategoryID = @id",
                    db.Parameter("@id", 1));
                    
                Console.WriteLine(name);
            }
        }
    }
}</PRE>
<LI>Default configuration. 
<P><I>App.config</I></P><PRE lang=xml>&lt;configuration&gt;
  &lt;appSettings&gt;
    &lt;add 
      key   = "ConnectionString" 
      value = 
       "Server=.;Database=NorthwindDev;Integrated Security=SSPI" /&gt;
  &lt;/appSettings&gt;
&lt;configuration&gt;</PRE>
<P><I>Test.cs</I></P><PRE lang=cs>using System;

using Rsdn.Framework.Data;

namespace Example
{
    class Test
    {
        static void Main()
        {
            using (DbManager db = new DbManager())
            {
                // ...
            }
        }
    }
}</PRE>
<LI>Advanced configuration. 
<P><I>App.config</I></P><PRE lang=cs>&lt;configuration&gt;
  &lt;appSettings&gt;
   &lt;add 
    key   = "ConnectionString.Development" 
    value = 
      "Server=.;Database=NorthwindDev;Integrated Security=SSPI" /&gt;
   &lt;add 
    key   = "ConnectionString.Production" 
    value = 
      "Server=.;Database=Northwind;Integrated Security=SSPI" /&gt;
  &lt;/appSettings&gt;
&lt;configuration&gt;</PRE>
<P><I>Test.cs</I></P><PRE lang=cs>using System;

using Rsdn.Framework.Data;

namespace Example
{
    class Test
    {
        static void Main()
        {
            using (DbManager db = new DbManager("Development"))
            {
                // ...
            }
        }
    }
}</PRE>
<LI>Adding a data provider - Borland Data Providers for .NET (BDP.NET). <PRE lang=cs>using System;
using System.Data;
using System.Data.Common;

using Borland.Data.Provider;

using Rsdn.Framework.Data;
using Rsdn.Framework.Data.DataProvider;

namespace Example
{
    public class BdpDataProvider: IDataProvider
    {
        IDbConnection IDataProvider.CreateConnectionObject()
        {
            return new BdpConnection();
        }
        
        DbDataAdapter IDataProvider.CreateDataAdapterObject()
        {
            return new BdpDataAdapter();
        }
        
        void IDataProvider.DeriveParameters(IDbCommand command)
        {
            BdpCommandBuilder.DeriveParameters((BdpCommand)command);
        }
        
        Type IDataProvider.ConnectionType
        {
            get
            {
                return typeof(BdpConnection);
            }
        }
        
        string IDataProvider.Name
        {
            get
            {
                return "Bdp";
            }
        }
    }
    
    class Test
    {
        static void Main()
        {
            DbManager.AddDataProvider(new BdpDataProvider());
            DbManager.AddConnectionString(".bdp",
                "assembly=Borland.Data.Mssql," + 
                "Version=1.1.0.0,Culture=neutral," +
                "PublicKeyToken=91d62ebb5b0d1b1b;" +
                "vendorclient=sqloledb.dll;osauthentication=True;" +
                "database=Northwind;" +
                "hostname=localhost;provider=MSSQL");
                
            using (DbManager db = new DbManager())
            {
                int count = 
                   (int)db.ExecuteScalar
                     ("SELECT Count(*) FROM Categories");
                
                Console.WriteLine(count);
            }
        }
    }
}</PRE>
<LI>Business object reading. <PRE lang=cs>using System;

using Rsdn.Framework.Data;

namespace Example
{
    public class Category
    {
        [MapField(Name="CategoryID")]
        public int ID;
        
        [MapField(Name="CategoryName")]
        public string Name;
        
        [MapField(IsNullable=true)]
        public string Description;
    }
    
    class Test
    {
        static void Main()
        {
            using (DbManager   db = new DbManager())
            {
                Category category = db.ExecuteBizEntity(
                    typeof(Category), @"
                    SELECT TOP 1
                        CategoryID,
                        CategoryName,
                        Description
                    FROM Categories");
                    
                if (category != null)
                {
                    Console.WriteLine("ID  : {0}\nName:" +
                        " {1}\nDesc: {2}",
                        category.ID, 
                        category.Name, category.Description);
                }
            }
        }
    }
}</PRE>
<LI>Stored procedure use (the idea was shamelessly stolen from The Microsoft Data Access Application Block for .NET). <PRE lang=cs>using System;
using System.Data;

using Rsdn.Framework.Data;

namespace Example
{
    class Test
    {
        static void Main()
        {
            using (DbManager db = new DbManager())
            {
                DataSet dataSet = 
                  db.ExecuteSpDataSet
                  ("SalesByCategory", "Seafood", null);
            }
        }
}</PRE>
<LI>Mapping an array of objects to the <CODE lang=cs>DataTable</CODE>. <PRE lang=cs>using System;
using System.Collections;
using System.Data;

using Rsdn.Framework.Data;

namespace Example
{
    public class BizEntity
    {
        public int    ID;
        public string Name;
    }
    
    class Test
    {
        static void Main()
        {
            DataTable table = new DataTable();
            
            table.Columns.Add("ID",   typeof(int));
            table.Columns.Add("Name", typeof(string));
            
            ArrayList array  = new ArrayList();
            BizEntity entity = new BizEntity();
            
            entity.ID   = 1;
            entity.Name = "Example";
            
            array.Add(entity);
            
            MapData.MapList(array, table);
            
            Console.WriteLine("ID  : {0}", 
                      table.Rows[0]["ID"]);
            Console.WriteLine("Name: {0}", 
                      table.Rows[0]["Name"]);
        }
    }
}</PRE>
<LI>Nested class mapping. <PRE lang=cs>public class RecordHeader
{
    public int    ID;
    public string Name;
}

public class Category
{
    public RecordHeader Header = new RecordHeader();
    public string       Description;
}

static ArrayList GetAllCategories()
{
    using (DbManager db = new DbManager())
    {
        return db.ExecuteList(
            typeof(Category), @"
            SELECT
                CategoryID   as [Header.ID],
                CategoryName as [Header.Name],
                Description
            FROM Categories");
    }
}</PRE></LI></OL>
<H2>Version 1.1 Fixes and Features</H2>
<H3>Features</H3>
<P>
<UL>
<LI>New <CODE>DbManager.ExecuteDictionary </CODE>method<BR>The method executes a query and returns the <CODE>Hashtable </CODE>of business entities. 
<LI>New <CODE>MapData.MapDictionary </CODE>method<BR>The method maps data from/to <CODE>Hashtable </CODE>or an object that implements the <CODE>IDictionary </CODE>interface. 
<LI>Support for <CODE>IDataReader </CODE>interface<BR>New overloaded versions of the <CODE>MapData.MapList </CODE>and <CODE>MapData.MapDictionary </CODE>methods added to support mapping from/to the <CODE>IDataReader</CODE>. 
<LI>Enhancement of the <CODE>MapValueAttribute </CODE>attribute<BR>Now the attribute can be applied to enumeration values. <PRE lang=cs>public enum Status
{
    [MapValue("A")] Active,
    [MapValue("I")] Inactive,
    [MapValue("P")] Pending
}</PRE>This is only way to define the attributes in Managed C++. 
<LI>New <CODE>RsdnDbManagerException </CODE>and <CODE>RsdnMapDataException </CODE>classes.<BR>All exceptions thrown by the library or used classes are wrapped in these exception classes and returned as inners. </LI></UL>
<H3>Fixes</H3>
<UL>
<LI>An exception occurs when attempting to add the <CODE>DbManager </CODE>to a form. </LI></UL>

<H2>Version 1.2 Fixes and Features</H2>
<H3>Features</H3>
<P>
<UL>
<LI>
The <CODE>MapData</CODE> class has been moved to the <CODE>Rsdn.Framework.Data.Mapping</CODE> 
namespace and renamed to <CODE>Map</CODE>. 
</LI>
<LI>
Support for abstract classes added.<br>
Now it's possible to skip implementation of class properties and define read-only class members.<br>
<pre lang=cs>
public abstract class MyBizEntity
{
    public abstract int    ID          { get; }
    public abstract string Description { get; set; }
}</pre></LI>
<li>New <code>MapTypeAttribute</code> attribute.</li>
<li>New <code>MapParameterAttribute</code> attribute.</li>
<li>New <code>MapIgnoreAttribute</code> attribute.</li>
<li>New <code>MapDescriptor</code> class.</li>
<li>New <code>IMapObjectFactory</code> interface.</li>
<li>Enhancement of the <code>MapFieldAttribute</code> attribute use.</li>
<li>Support for nullable types added.</li>
<li>Support for the Guid type added.</li>
<li>Xml schema mapping added.<br>
	The <code>SetMappingSchema</code> method can be used to assign default mapping schema.</li>
<li>New <code>MapXmlAttribute</code> attribute.</li>
</UL>
<H3>Fixes</H3>
<UL>
<LI>Couple of minor bugs has been fixed.</LI>
</UL>

<p>
The major changes of this version apply to mapping features. 
The <code>MapData</code> class was renamed and moved to the <code>Rsdn.Framework.Data.Mapping</code> namespace.
Some methods of the class were renamed as well. Old names decorated with the <code>Obsolete</code> attribute 
and will be removed with the next version of the library.
</p>

<H3>Abstract classes</H3>
<p>
Support for abstract classes allows to get actually declarative business object definition and to skip implementation of properties. The following example demonstrates typical business object definition:
</p>
<pre lang=cs>public class MyBizEntity
{
    private int _id;
    public  int  ID
    {
        get { return _id;  }
        set { _id = value; }
    }

    private string _description;
    public  string  Description
    {
        get { return _description;  }
        set { _description = value; }
    }
}</pre>
<p>Abstract definition looks like the following:</p>
<pre lang=cs>public abstract class MyBizEntity
{
    public abstract int    ID          { get; }
    public abstract string Description { get; set; }
}</pre>
<p>This way is a little bit shorter and allows to define read-only class properties.</p>

<h3>MapTypeAttribute</h3>
<p>
If one of the abstract properties has to be implemented by different from return value type, 
the <code>MapTypeAttribute</code> attribute can be used. 
Suppose we have internal property implementation using the following class:
</p>
<pre lang=cs>public class MyString
{
    private string _value;
    public  string  Value
    {
        get { return _value;  }
        set { _value = value; }
    }
}</pre>
<p>
Typical property definition could be the following:
</p>
<pre lang=cs>public class MyBizEntity
{
    private MyString _description;
    public  string    Description
    {
        get { return _description.Value;  }
        set { _description.Value = value; }
    }
}</pre>
<p>
Abstract property definition:
</p>
<pre lang=cs>public abstract class MyBizEntity
{
    [MapType(typeof(MyString))]
    public abstract string Description { get; set; }
}</pre>
<p>
In this case the mapper expects that <code>MyString</code> has <code>Value</code> property and 
the property type is coincident with the property return value type.
</p>

<h3>MapIgnoreAttribute</h3>
<p>
This attribute excludes a class member from the mapping. 
</p>

<h3>MapDescriptor</h3>
<p>
The <code>MapDescriptor</code> class represents a mapped type descriptor. It consists of methods that can be used 
to create business objects and to access object members. 
The following example demonstrates how to create an instance of the <code>MyBizEntity</code> class and 
to assign a value to its read-only property ID:
</p>
<pre lang=cs>MapDescriptor desc   = MapDescriptor.GetDescriptor(typeof(MyBizEntity));
MyBizEntity   entity = desc.CreateInstance() as MyBizEntity;

Desc["ID"].SetValue(entity, 1);</pre>
<p>
Actually, this way is not designed for daily use. Hovever, it can be useful as a "back door" 
to develop various frameworks.
</p>

<h3>IMapObjectFactory</h3>
<p>
This interface allows to control the business object creation process. 
</p>
<pre lang=cs>public MyBizEntityManager : IMapObjectFactory
{
    private MapDescriptor _descriptor;

    public MyBizEntityManager()
    {
        _descriptor = MapDescriptor.getDescriptor(typeof(MyBizEntity));
        _descriptor.ObjectFactory = this;
    }

    object IMapObjectFactory.CreateInstance(
        IMapDataSource dataSource,
        object         sourceObject,
        object[]       parameters,
        ref bool       stopMapping)
    {
        return _descriptor.CreateInstance(
            dataSource, sourceObject, parameters, stopMapping);
    }
}</pre>
<p>
As you see, the object is created by using type descriptor. However, it's not required.
</p>

<h3>MapFieldAttribute</h3>
<p>
Now this attribute can be applied to a class itself. In this case, 
it specifies additional naming of source and target objects that can not be done in normal way.
</p>
<pre lang=cs>public class BaseBizEntity
{
    public int ID;
}

[MapField(SourceName="OrderID", TargetName="ID")]
public class Order : BaseBizEntity
{
    public int Number;
}

[MapField("CustomerID", "ID")]
[MapField("OrderID",    "Order.ID")]
public class Customer : BaseBizEntity
{
    public string Name;
    public Order  Order = new Order();
}</pre>

<h3>Nullable values</h3>
<p>
Now the mapper supports nullable types such as System.Data.SqlTypes and its analogues.
</p>
<pre lang=cs>public abstract class MyBizEntity
{
    public abstract SqlString Description { get; set; }
}</pre>
<p>
The mapper expects the presence of the Value and IsNull properties of these types.
</p>

<h3>Guid</h3>
<p>Support for the Guid type added.</p>

<h3>Xml mapping schemas</h3>
<p>
Generally, xml mapping schema looks like the following:
</p>
<pre>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;mapping xmlns="http://www.rsdn.ru/mapping.xsd"&gt;
    &lt;type name="NamespaceName.TypeName"&gt;
        &lt;field name="field1" source="field1" trimmable="true" /&gt;
        &lt;field name="field2"&gt;
            &lt;value target="3" source="2" source_type="System.Int32" /&gt;
        &lt;/field&gt;
        &lt;field name="field3" nullable="true"&gt;
            &lt;value target="3" source="2" source_type="System.Int32" /&gt;
            &lt;null_value target="111"/&gt;
        &lt;/field&gt;
        &lt;field name="field4" ignore="true" /&gt;
    &lt;/type&gt;
    &lt;value_type name="NamespaceName.ValueTypeName "&gt;
        &lt;value target="Active"   source="A" source_type="System.String" /&gt;
        &lt;value target="Inactive" source="I" source_type="System.String" /&gt;
        &lt;value target="Pending"  source="P" source_type="System.String" /&gt;
        &lt;null_value target="Unknown"/&gt;
    &lt;/value_type&gt;
&lt;/mapping&gt;</pre>
<p>
The <code>type</code> tag defines mapping schema of the particular type. 
The <code>value_type</code> tag is used to define mapping for enumerators.
The <code>SetMappingSchema</code> overrides register a default xml mapping schema.
The <code>SetMappingSchema(string)</code> method performs a search of schema file for provided name. 
If the file is not found, the method tries to find it in the calling assembly resources.
If the type has mapping attribute, the xml schema has a higher priority. For example:
</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;mapping xmlns="http://www.rsdn.ru/mapping.xsd"&gt;
    &lt;type name="NamespaceName.Dest"&gt;
        &lt;field name="Field1"&gt;
            &lt;null_value target="-1" /&gt;
        &lt;/field&gt;
    &lt;/type&gt;
&lt;/mapping&gt;</pre>

<pre lang=cs>
public class Src
{
    public object Field1 = null;
    public object Field2 = null;
}

public class Dest
{
    [MapNullValue(-2)]
    public int Field1;

    [MapNullValue(-3)]
    public int Field2;
}

void Test()
{
    MapDescriptor.SetMappingSchema("Map.xml");

    Src  s = new Src();
    Dest d = Map.ToObject(s, typeof(Dest)) as Dest;

    // d.Field1 == -1
    // d.Field2 == -3
}</pre>
<p>
During the test execution, xml schema is used to assign <code>Field1</code> field value. 
<code>Field2</code> is assigned from the attribute.
</p>

<h3>MapXmlAttribute</h3>
<p>
This attribute specifies xml file name and path to type definition. For example:
</p>
<pre>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;mapping xmlns="http://www.rsdn.ru/mapping.xsd"&gt;
    &lt;type name="MyBizEntity"&gt;
        ...
    &lt;/type&gt;
&lt;/mapping&gt;</pre>

<pre lang=cs>[MapXml("MyMapping.xml", "MyBizEntity")]
public class MyBizEntity
{
    // ...
}</pre>
<p>
If xml schema is set by <code>SetMappingSchema</code> method, single attribute parameter can be used:
</p>
<pre>[MapXml("MyBizEntity")]
public class MyBizEntity
{
    // ...
}</pre>

<h3>Known Problems</h3>
<ul>
<li>
During the abstract class mapping the mapper creates a derived class that implements abstract properties.
Obviously, the full name of the class is different from the original name. 
Name of the generated class is the following: 
<pre>
NamespaceName.AbstractClassName.MappingExtension.AbstractClassName
</pre>
So, the <code>GetType().Name</code> property returns the same name for the original and derived classes.
The <code>GetType().FullName</code> method returns different ones.
Also direct type comparison does not work correctly.
<pre lang=cs>
MyBizEntity entity = MapDescriptor.GetDescriptor
    (typeof(MyBizEntity)).CreateInstanceEx();

if (entity.GetType() == typeof(MyBizEntity)) {}  // false
if (entity is MyBizEntity) {}                    // true</pre>
</li>
<li>
As dynamic assemblies are generated in memory, they don't implement some methods and throw the 
<code>NonImplementedException</code> when the methods are addressed. 
This issue can be solved by the explicit assembly type check. 
<pre lang=cs>foreach (Assembly a in AppDomain.CurrentDomain.GetAssemblies())
{
    if (a is System.Reflection.Emit.AssemblyBuilder)
        continue;

    Console.WriteLine(a.CodeBase);
}</pre>
</li>
</ul>




<!----------------------------- Article Ends ----------------------------->