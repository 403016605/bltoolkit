<#@ assembly name="System.Core"    #>
<#@ assembly name="System.Data"    #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Linq" #>
<#
	AppDomain.CurrentDomain.AssemblyResolve += (_,args) =>
	{
		foreach (var a in Assemblies)
			if (args.Name.ToLower().IndexOf(a.Key.ToLower()) >= 0)
				return System.Reflection.Assembly.LoadFile(a.Value);
	
		if (DataProviderAssembly != null)
			return System.Reflection.Assembly.LoadFile(DataProviderAssembly);

		return null;
	};
#><#+

static Dictionary<string,string> Assemblies = new Dictionary<string,string>();

static Action<GeneratedTextTransformation,string> WriteComment        = (tt,s) => tt.WriteLine("//{0}", s);
static Action<GeneratedTextTransformation,string> WriteUsing          = (tt,s) => tt.WriteLine("using {0};", s);
static Action<GeneratedTextTransformation,string> WriteBeginNamespace = (tt,s) => { tt.WriteLine("namespace {0}", s); tt.WriteLine("{"); };
static Action<GeneratedTextTransformation>        WriteEndNamespace   =  tt    => tt.WriteLine("}");
static Action<GeneratedTextTransformation,string,string> WriteBeginClass = (tt,cl,bc) =>
{
	tt.Write("public partial class {0}", cl);
	if (!string.IsNullOrEmpty(bc))
		tt.Write(" : {0}", bc);
	tt.WriteLine("");
	tt.WriteLine("{");
};
static Action<GeneratedTextTransformation>        WriteEndClass       =  tt   => tt.WriteLine("}");
static Func<string,string,string>                 MakeGenericType     = (c,t) => string.Format("{0}<{1}>", c, t);
static Func<string,string>                        MakeType            = t     => t;
static Action<GeneratedTextTransformation,string,int> WriteTableProperty = (tt,name,maxlen) =>
{
	tt.WriteLine("public Table<{0}>{1} {0}{1} {{ get {{ return this.GetTable<{0}>();{1} }} }}", name, tt.LenDiff(maxlen, name));
};
static Action<GeneratedTextTransformation,string> WriteAttribute      = (tt,a) => tt.Write("[{0}]", a);
static Action<GeneratedTextTransformation>        WriteAttributeLine  =  tt    => tt.WriteLine("");

string ConnectionString;
string ConnectionType;
string DataProviderAssembly = null;

string DatabaseName             = null;
string DataContextName          = null;
string Namespace                = "DataModel";
string BaseDataContextClass     = "DbManager";
string BaseEntityClass          = null;
string OneToManyAssociationType = "IEnumerable<{0}>";

bool   RenderField = false;

bool   IsMetadataLoaded;

int MaxColumnTypeLen;
int MaxColumnMemberLen;

static Action<GeneratedTextTransformation,Column,int[],string[]> RenderColumn = (tt,c,maxLens,attrs) =>
{
	if (maxLens.Sum() > 0)
	{
		if (attrs.Any(_ => _ != null))
		{
			tt.Write("[");

			for (var i = 0; i < attrs.Length; i++)
			{
				if (attrs[i] != null)
				{
					tt.Write(attrs[i]);
					tt.WriteSpace(maxLens[i] - attrs[i].Length);

					if (attrs.Skip(i + 1).Any(_ => _ != null))
						tt.Write(", ");
					else if (maxLens.Skip(i + 1).Any(_ => _ > 0))
						tt.WriteSpace(2);
				}
				else if (maxLens[i] > 0)
				{
					tt.WriteSpace(maxLens[i]);
					
					if (maxLens.Skip(i + 1).Any(_ => _ > 0))
						tt.WriteSpace(2);
				}
			}

			tt.Write("] ");
		}
		else
		{
			tt.WriteSpace(maxLens.Sum() + (maxLens.Where(_ => _ > 0).Count() - 1) * 2 + 3);
		}
	}

	tt.Write("public {0}{1} {2}", c.Type, tt.LenDiff(tt.MaxColumnTypeLen, c.Type), c.MemberName);

	if (tt.RenderField)
		tt.WriteLine(";");
	else
		tt.WriteLine("{0} {{ get; set; }}", tt.LenDiff(tt.MaxColumnMemberLen, c.MemberName));
};

static Action<GeneratedTextTransformation,ForeignKey> RenderForeignKey = (tt,key) =>
{
	WriteComment(tt, " " + key.KeyName);
	tt.WriteLine("[Association(ThisKey=\"{0}\", OtherKey=\"{1}\")]",
		string.Join(", ", (from c in key.ThisColumns  select c.MemberName).ToArray()),
		string.Join(", ", (from c in key.OtherColumns select c.MemberName).ToArray()));

	tt.Write("public ");

	if (key.AssociationType == AssociationType.OneToMany)
		tt.Write(tt.OneToManyAssociationType, key.OtherTable.ClassName);
	else
		tt.Write(key.OtherTable.ClassName);

	tt.Write(" ");
	tt.Write(key.MemberName);

	if (tt.RenderField)
		tt.WriteLine(";");
	else
		tt.WriteLine(" { get; set; }");
};

static Action<GeneratedTextTransformation,Table> RenderTable = (tt,t) =>
{
	RenderTableAttributes(tt, t);

	WriteBeginClass(tt, t.ClassName, t.BaseClassName);
	
	tt.PushIndent("\t");

	tt.MaxColumnTypeLen   = t.Columns.Values.Max(_ => _.Type.Length);
	tt.MaxColumnMemberLen = t.Columns.Values.Max(_ => _.MemberName.Length);

	var maxLens = new int[]
	{
		t.Columns.Values.Max(_ => _.MemberName == _.ColumnName ? 0 : "MapField('')".Length + _.ColumnName.Length),
		t.Columns.Values.Max(_ => _.IsNullable                 ? "Nullable".Length : _.IsIdentity ? "Identity".Length : 0),
		t.Columns.Values.Max(_ => _.IsIdentity && _.IsNullable ? "Identity".Length : 0),
		t.Columns.Values.Max(_ => _.IsPrimaryKey               ? string.Format("PrimaryKey({0})", _.PKIndex).Length : 0),
		t.Columns.Values.Max(_ => _.Attributes.Count == 0      ? 0 : string.Join(", ", _.Attributes.Distinct().ToArray()).Length),
	};

	foreach (var c in from c in t.Columns.Values orderby c.ID select c)
	{
		var attrs = new string[]
		{
			c.MemberName == c.ColumnName ? null : string.Format("MapField(\"{0}\")", c.ColumnName),
			c.IsNullable                 ? "Nullable" : c.IsIdentity ? "Identity" : null,
			c.IsIdentity && c.IsNullable ? "Identity" : null,
			c.IsPrimaryKey               ? string.Format("PrimaryKey({0})", c.PKIndex) : null,
			c.Attributes.Count == 0      ? null : string.Join(", ", c.Attributes.Distinct().ToArray()),
		};

		RenderColumn(tt, c, maxLens, attrs);
	}

	if (t.ForeignKeys.Count > 0)
	{
		foreach (var key in t.ForeignKeys.Values)
		{
			tt.WriteLine("");
			RenderForeignKey(tt, key);
		}
	}

	tt.PopIndent();
	WriteEndClass(tt);
};

static Action<GeneratedTextTransformation,Table> RenderTableAttributes = (tt,t) =>
{
	if (t.Attributes.Count > 0)
	{
		WriteAttribute(tt, string.Join(", ", t.Attributes.Distinct().ToArray()));
		WriteAttributeLine(tt);
	}

	string tbl = "TableName(";

	if (!string.IsNullOrEmpty(tt.DatabaseName))
		tbl += string.Format("Database=\"{0}\", ", tt.DatabaseName);

	if (!string.IsNullOrEmpty(t.Owner))
		tbl += string.Format("Owner=\"{0}\", ", t.Owner);

	tbl += string.Format("Name=\"{0}\")", t.TableName);

	WriteAttribute(tt, tbl);
	WriteAttributeLine(tt);
};

List<string> Usings = new List<string>()
{
	"System",
	"BLToolkit.Data",
	"BLToolkit.Data.Linq",
	"BLToolkit.DataAccess",
	"BLToolkit.Mapping",
};

static Action<GeneratedTextTransformation> RenderUsing = tt =>
{
	var q =
		from ns in tt.Usings.Distinct()
		group ns by ns.Split('.')[0];

	var groups =
		(from ns in q where ns.Key == "System"                select ns).Concat
		(from ns in q where ns.Key != "System" orderby ns.Key select ns);

	foreach (var gr in groups)
	{
		foreach (var ns in from s in gr orderby s select s)
			WriteUsing(tt, ns);

		tt.WriteLine("");
	}
};

Action<GeneratedTextTransformation> BeforeGenerateModel = _ => {};
Action<GeneratedTextTransformation> AfterGenerateModel  = _ => {};

void GenerateModel()
{
	if (ConnectionString != null) ConnectionString = ConnectionString.Trim();
	if (DataContextName  != null) DataContextName  = DataContextName. Trim();

	if (string.IsNullOrEmpty(ConnectionString)) { Error("ConnectionString cannot be empty."); return; }

	if (string.IsNullOrEmpty(DataContextName))
		DataContextName = "DataContext";

	LoadMetadata();

	BeforeGenerateModel(this);

	WriteComment(this, "---------------------------------------------------------------------------------------------------");
	WriteComment(this, " <auto-generated>");
	WriteComment(this, "    This code was generated by BLToolkit template for T4.");
	WriteComment(this, "    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
	WriteComment(this, " </auto-generated>");
	WriteComment(this, "---------------------------------------------------------------------------------------------------");

	RenderUsing(this);

	WriteBeginNamespace(this, Namespace);
	PushIndent("\t");

	WriteBeginClass(this, DataContextName, BaseDataContextClass);

	var tlist  = (from t in Tables.Values orderby t.TableName select t).ToList();
	var maxlen = tlist.Max(_ => _.ClassName.Length);

	PushIndent("\t");

	foreach (var t in tlist)
		WriteTableProperty(this, t.ClassName, maxlen);

	PopIndent();

	WriteEndClass(this);

	foreach (var t in tlist)
	{
		WriteLine("");
		RenderTable(this, t);
	}

	PopIndent();
	WriteEndNamespace(this);

	AfterGenerateModel(this);
}

string LenDiff(int max, string str)
{
	var s = "";

	while (max-- > str.Length)
		s += " ";

	return s;
}

void WriteSpace(int len)
{
	while (len-- > 0)
		Write(" ");
}

List<T> CreateList<T>(T item)
{
	return new List<T>();
}

System.Data.IDbConnection GetConnection()
{
	Type connType = null;

	if (DataProviderAssembly != null)
	{
		try
		{
			var assembly = System.Reflection.Assembly.LoadFile(DataProviderAssembly);
			connType = assembly.GetType(ConnectionType);
		}
		catch
		{
		}
	}

	if (connType == null)
		connType = Type.GetType(ConnectionType);

	var conn = (System.Data.IDbConnection)Activator.CreateInstance(connType);

	conn.ConnectionString = ConnectionString;
	conn.Open();

	return conn;
}

void LoadMetadata()
{
	if (IsMetadataLoaded)
		return;

	IsMetadataLoaded = true;

	BeforeLoadMetadata(this);
	LoadServerMetadata();

	foreach (var t in Tables.Values)
	{
		if (t.ClassName.Contains(" "))
		{
			var ss = t.ClassName.Split(' ').Where(_ => _.Trim().Length > 0).Select(_ => char.ToUpper(_[0]) + _.Substring(1));
			t.ClassName = string.Join("", ss.ToArray());
		}
	}

	foreach (var t in Tables.Values)
		foreach (var key in t.ForeignKeys.Values.ToList())
			if (!key.KeyName.EndsWith("_BackReference"))
				key.OtherTable.ForeignKeys.Add(key.KeyName + "_BackReference", key.BackReference = new ForeignKey
				{
					KeyName         = key.KeyName    + "_BackReference",
					MemberName      = key.MemberName + "_BackReference",
					AssociationType = AssociationType.Auto,
					OtherTable      = t,
					ThisColumns     = key.OtherColumns,
					OtherColumns    = key.ThisColumns
				});

	foreach (var t in Tables.Values)
	{
		foreach (var key in t.ForeignKeys.Values)
		{
			if (key.BackReference != null && key.AssociationType == AssociationType.Auto)
			{
				if (key.ThisColumns.All(_ => _.IsPrimaryKey))
				{
					if (t.Columns.Values.Count(_ => _.IsPrimaryKey) == key.ThisColumns.Count)
						key.AssociationType = AssociationType.OneToOne;
					else
						key.AssociationType = AssociationType.ManyToOne;
				}
				else
					key.AssociationType = AssociationType.ManyToOne;
			}
		}
	}

	foreach (var t in Tables.Values)
	{
		foreach (var key in t.ForeignKeys.Values)
		{
			var name = key.MemberName;

			if (key.BackReference != null && key.ThisColumns.Count == 1 && key.ThisColumns[0].MemberName.ToLower().EndsWith("id"))
			{
				name = key.ThisColumns[0].MemberName;
				name = name.Substring(0, name.Length - "id".Length);

				if (!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
					 t.Columns.    Values.Select(_ => _.MemberName)).Concat(
					 new[] { t.ClassName }).Any(_ => _ == name))
				{
					name = key.MemberName;;
				}
			}
			
			if (name == key.MemberName)
			{
				if (name.StartsWith("FK_"))
					name = name.Substring(3);

				if (name.EndsWith("_BackReference"))
					name = name.Substring(0, name.Length - "_BackReference".Length);

				name = string.Join("", name.Split('_').Where(_ => _.Length > 0 && _ != t.TableName).ToArray());

				if (key.AssociationType == AssociationType.OneToMany)
					name += "s";
			}

			if (name.Length != 0 &&
				!t.ForeignKeys.Values.Select(_ => _.MemberName).Concat(
				 t.Columns.    Values.Select(_ => _.MemberName)).Concat(
				 new[] { t.ClassName }).Any(_ => _ == name))
			{
				key.MemberName = name;
			}
		}
	}

	if (Tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == AssociationType.OneToMany))
		Usings.Add("System.Collections.Generic");

	AfterLoadMetadata(this);
}

Action<GeneratedTextTransformation> BeforeLoadMetadata = _ => {};
Action<GeneratedTextTransformation> AfterLoadMetadata  = _ => {};

Dictionary<string,Table> Tables = new Dictionary<string,Table>();

partial class Table
{
	public string       Owner;
	public string       TableName;
	public string       ClassName;
	public string       BaseClassName;
	public bool         IsView;
	public List<string> Attributes = new List<string>();

	public Dictionary<string,Column>     Columns     = new Dictionary<string,Column>();
	public Dictionary<string,ForeignKey> ForeignKeys = new Dictionary<string,ForeignKey>();
}

partial class Column
{
	public int          ID;
	public string       ColumnName;
	public string       MemberName;
	public bool         IsNullable;
	public bool         IsIdentity;
	public string       Type;
	public bool         IsClass;
	public DbType       DbType;
	public SqlDbType    SqlDbType;
	public int          PKIndex = -1;
	public List<string> Attributes = new List<string>();

	public bool IsPrimaryKey { get { return PKIndex >= 0; } }
}

enum AssociationType
{
	Auto,
	OneToOne,
	OneToMany,
	ManyToOne,
}

partial class ForeignKey
{
	public string          KeyName;
	public string          MemberName;
	public Table           OtherTable;
	public List<Column>    ThisColumns  = new List<Column>();
	public List<Column>    OtherColumns = new List<Column>();
	public ForeignKey      BackReference;

	private AssociationType _associationType = AssociationType.Auto;
	public  AssociationType  AssociationType
	{
		get { return _associationType; }
		set
		{
			_associationType = value;

			if (BackReference != null)
			{
				switch (value)
				{
					case AssociationType.Auto      : BackReference.AssociationType = AssociationType.Auto;      break;
					case AssociationType.OneToOne  : BackReference.AssociationType = AssociationType.OneToOne;  break;
					case AssociationType.OneToMany : BackReference.AssociationType = AssociationType.ManyToOne; break;
					case AssociationType.ManyToOne : BackReference.AssociationType = AssociationType.OneToMany; break;
				}
			}
		}
	}
}

/*
// Shamelessly jacked from http://www.bennysutton.com/C-sharp/Plural-Singular-Words.aspx with little modifications.
//

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

/// <summary>
/// Convert words to and from singulars/plurals
/// Copyright www.BennySutton.com 2008
/// You may reuse this code BUT not for sale AND ONLY with credit to www.BennySutton.com
/// </summary>
public sealed class Plurals
{
	/// <summary>
	/// Store irregular plurals in a dictionary
	/// </summary>
	private static Dictionary<string, string> _dictionary = new Dictionary<string, string>();

	#region Constructors
	
	/// <summary>
	/// The singleton instance (thanks to dotnetpearls.com for help here)
	/// </summary>
	static readonly Plurals _instance = new Plurals();
	/// <summary>
	/// Get an instance of the structure singleton. This effectively caches the dictionary 
	/// </summary>
	public static Plurals Instance
	{
		get
		{
			// Fastest solution that avoids null check and is thread-safe
			// because of readonly keyword.
			return _instance;
		}
	}
	
	/// <summary>
	/// Run initialization on this singleton class
	/// </summary>
	private Plurals()
	{
		Initialize();
	}

	private void Initialize()
	{
		//to test that this class only initializes once uncomment next line
		//System.Web.HttpContext.Current.Response.Write("initializing singleton <br>");
		// irregular plurals
		_dictionary.Add("afterlife",    "afterlives");
		_dictionary.Add("alga",         "algae");
		_dictionary.Add("alumna",       "alumnae");
		_dictionary.Add("alumnus",      "alumni");
		_dictionary.Add("analysis",     "analyses");
		_dictionary.Add("antenna",      "antennae");
		_dictionary.Add("appendix",     "appendices");
		_dictionary.Add("axis",         "axes");
		_dictionary.Add("bacillus",     "bacilli");
		_dictionary.Add("basis",        "bases");
		_dictionary.Add("Bedouin",      "Bedouin");
		_dictionary.Add("cactus",       "cacti");
		_dictionary.Add("calf",         "calves");
		_dictionary.Add("cherub",       "cherubim");
		_dictionary.Add("child",        "children");
		_dictionary.Add("cod",          "cod");
		_dictionary.Add("cookie",       "cookies");
		_dictionary.Add("criterion",    "criteria");
		_dictionary.Add("curriculum",   "curricula");
		_dictionary.Add("datum",        "data");
		_dictionary.Add("deer",         "deer");
		_dictionary.Add("diagnosis",    "diagnoses");
		_dictionary.Add("die",          "dice");
		_dictionary.Add("dormouse",     "dormice");
		_dictionary.Add("elf",          "elves");
		_dictionary.Add("elk",          "elk");
		_dictionary.Add("erratum",      "errata");
		_dictionary.Add("esophagus",    "esophagi");
		_dictionary.Add("fauna",        "faunae");
		_dictionary.Add("fish",         "fish");
		_dictionary.Add("flora",        "florae");
		_dictionary.Add("focus",        "foci");
		_dictionary.Add("foot",         "feet");
		_dictionary.Add("formula",      "formulae");
		_dictionary.Add("fundus",       "fundi");
		_dictionary.Add("fungus",       "fungi");
		_dictionary.Add("genie",        "genii");
		_dictionary.Add("genus",        "genera");
		_dictionary.Add("goose",        "geese");
		_dictionary.Add("grouse",       "grouse");
		_dictionary.Add("hake",         "hake");
		_dictionary.Add("half",         "halves");
		_dictionary.Add("headquarters", "headquarters");
		_dictionary.Add("hippo",        "hippos");
		_dictionary.Add("hippopotamus", "hippopotami");
		_dictionary.Add("hoof",         "hooves");
		_dictionary.Add("housewife",    "housewives");
		_dictionary.Add("hypothesis",   "hypotheses");
		_dictionary.Add("index",        "indices");
		_dictionary.Add("jackknife",    "jackknives");
		_dictionary.Add("knife",        "knives");
		_dictionary.Add("labium",       "labia");
		_dictionary.Add("larva",        "larvae");
		_dictionary.Add("leaf",         "leaves");
		_dictionary.Add("life",         "lives");
		_dictionary.Add("loaf",         "loaves");
		_dictionary.Add("louse",        "lice");
		_dictionary.Add("magus",        "magi");
		_dictionary.Add("man",          "men");
		_dictionary.Add("memorandum",   "memoranda");
		_dictionary.Add("midwife",      "midwives");
		_dictionary.Add("millennium",   "millennia");
		_dictionary.Add("moose",        "moose");
		_dictionary.Add("mouse",        "mice");
		_dictionary.Add("nebula",       "nebulae");
		_dictionary.Add("neurosis",     "neuroses");
		_dictionary.Add("nova",         "novas");
		_dictionary.Add("nucleus",      "nuclei");
		_dictionary.Add("oesophagus",   "oesophagi");
		_dictionary.Add("offspring",    "offspring");
		_dictionary.Add("ovum",         "ova");
		_dictionary.Add("ox",           "oxen");
		_dictionary.Add("papyrus",      "papyri");
		_dictionary.Add("passerby",     "passersby");
		_dictionary.Add("penknife",     "penknives");
		_dictionary.Add("person",       "people");
		_dictionary.Add("phenomenon",   "phenomena");
		_dictionary.Add("placenta",     "placentae");
		_dictionary.Add("pocketknife",  "pocketknives");
		_dictionary.Add("pupa",         "pupae");
		_dictionary.Add("radius",       "radii");
		_dictionary.Add("reindeer",     "reindeer");
		_dictionary.Add("retina",       "retinae");
		_dictionary.Add("rhinoceros",   "rhinoceros");
		_dictionary.Add("roe",          "roe");
		_dictionary.Add("salmon",       "salmon");
		_dictionary.Add("scarf",        "scarves");
		_dictionary.Add("self",         "selves");
		_dictionary.Add("seraph",       "seraphim");
		_dictionary.Add("series",       "series");
		_dictionary.Add("sheaf",        "sheaves");
		_dictionary.Add("sheep",        "sheep");
		_dictionary.Add("shelf",        "shelves");
		_dictionary.Add("species",      "species");
		_dictionary.Add("spectrum",     "spectra");
		_dictionary.Add("stimulus",     "stimuli");
		_dictionary.Add("stratum",      "strata");
		_dictionary.Add("supernova",    "supernovas");
		_dictionary.Add("swine",        "swine");
		_dictionary.Add("terminus",     "termini");
		_dictionary.Add("thesaurus",    "thesauri");
		_dictionary.Add("thesis",       "theses");
		_dictionary.Add("thief",        "thieves");
		_dictionary.Add("trout",        "trout");
		_dictionary.Add("vulva",        "vulvae");
		_dictionary.Add("wife",         "wives");
		_dictionary.Add("wildebeest",   "wildebeest");
		_dictionary.Add("wolf",         "wolves");
		_dictionary.Add("woman",        "women");
		_dictionary.Add("yen",          "yen");
	}
	
	#endregion //Constructors

	#region Methods
	
	/// <summary>
	/// Call this method to get the properly pluralized 
	/// English version of the word.
	/// </summary>
	/// <param name="word">The word needing conditional pluralization.</param>
	/// <param name="count">The number of items the word refers to.</param>
	/// <returns>The pluralized word</returns>
	static public string ToPlural(string word)
	{
		if (TestIsPlural(word) == true)
		{
			return word; //it's already a plural
		}
		else if (_dictionary.ContainsKey(word.ToLower())) 
		//it's an irregular plural, use the word from the dictionary
		{
			return _dictionary[word.ToLower()];
		}
		
		if (word.Length <= 2)
		{
			return word; //not a word that can be pluralised!
		}
		
		////1. If the word ends in a consonant plus -y, change the -y into
		///-ie and add an -s to form the plural 
		///e.g. enemy--enemies baby--babies
		switch (word.Substring(word.Length - 2))
		{
			case "by":
			case "cy":
			case "dy":
			case "fy":
			case "gy":
			case "hy":
			case "jy":
			case "ky":
			case "ly":
			case "my":
			case "ny":
			case "py":
			case "ry":
			case "sy":
			case "ty":
			case "vy":
			case "wy":
			case "xy":
			case "zy":
				{
					return word.Substring(0, word.Length - 1) + "ies";
				}

			//2. For words that end in -is, change the -is to -es to make the plural form.
			//synopsis--synopses 
			//thesis--theses 
			case "is":
				{
					return word.Substring(0, word.Length - 1) + "es";
				}

			//3. For words that end in a "hissing" sound (s,z,x,ch,sh), add an -es to form the plural.
			//box--boxes 
			//church--churches
			case "ch":
			case "sh":
				{
					return word + "es";
				}
			default:
				{
					switch (word.Substring(word.Length - 1))
					{
						case "s":
						case "z":
						case "x":
							{
								return word + "es";
							}
						default:
							{
								//4. Assume add an -s to form the plural of most words.
								return word + "s";
							}
					}
				}
		}
	}
	
	/// <summary>
	/// Call this method to get the singular 
	/// version of a plural English word.
	/// </summary>
	/// <param name="word">The word to turn into a singular</param>
	/// <returns>The singular word</returns>
	static public string ToSingular(string word)
	{
		word = word.ToLower();

		if (_dictionary.ContainsValue(word))
		{
			foreach (KeyValuePair<string, string> kvp in _dictionary)
			{
				if (kvp.Value.ToLower() == word) return kvp.Key;
			}
		}

		if (word.Substring(word.Length - 1) != "s")
		{
			return word; // not a plural word if it doesn't end in S
		}

		if (word.Length <= 2)
		{
			return word; // not a word that can be made singular if only two letters!
		}

		if (word.Length >= 4)
		{
			//1. If the word ends in a consonant plus -y, change the -y into -ie and add an -s to form the plural – so reverse engineer it to get the singular
			// e.g. enemy--enemies baby--babies family--families
			switch (word.Substring(word.Length - 4))
			{
				case "bies":
				case "cies":
				case "dies":
				case "fies":
				case "gies":
				case "hies":
				case "jies":
				case "kies":
				case "lies":
				case "mies":
				case "nies":
				case "pies":
				case "ries":
				case "sies":
				case "ties":
				case "vies":
				case "wies":
				case "xies":
				case "zies":
					{
						return word.Substring(0, word.Length - 3) + "y";
					}
				//3. For words that end in a "hissing" sound (s,z,x,ch,sh), add an -es to form the plural.
				//church--churches
				case "ches":
				case "shes":
					{
						return word.Substring(0, word.Length - 2);
					}
			}
		}

		if (word.Length >= 3)
		{
			switch (word.Substring(word.Length - 3))
			{
				//box--boxes 
				case "ses":
				//NOTE some false positives here - For words that end in -is, change the -is to -es to make the plural form.
				//synopsis--synopses 
				//thesis--theses 
				case "zes":
				case "xes":
					{
						return word.Substring(0, word.Length - 2);
					}
			}
		}

		if (word.Length >= 3)
		{
			switch (word.Substring(word.Length - 2))
			{
				case "es":
					{
						return word.Substring(0, word.Length - 1) + "is";
					}
				//4. Assume add an -s to form the plural of most words.
				default:
					{
						return word.Substring(0, word.Length - 1);
					}
			}
		}

		return word;
	}

	/// <summary>
	/// test if a word is plural
	/// </summary>
	/// <param name="word">word to test</param>
	/// <returns>true if a word is plural</returns>
	static public bool TestIsPlural(string word)
	{
		word = word.ToLower();

		if (word.Length <= 2)
		{
			return false; // not a word that can be made singular if only two letters!
		}

		if (_dictionary.ContainsValue(word.ToLower()))
		{
			return true; //it's definitely already a plural
		}

		if (word.Length >= 4)
		{
			//1. If the word ends in a consonant plus -y, change the -y into -ie and add an -s to form the plural 
			// e.g. enemy--enemies baby--babies family--families
			switch (word.Substring(word.Length - 4))
			{
				case "bies":
				case "cies":
				case "dies":
				case "fies":
				case "gies":
				case "hies":
				case "jies":
				case "kies":
				case "lies":
				case "mies":
				case "nies":
				case "pies":
				case "ries":
				case "sies":
				case "ties":
				case "vies":
				case "wies":
				case "xies":
				case "zies":
				case "ches":
				case "shes":
					{
						return true;
					}
			}
		}

		if (word.Length >= 3)
		{
			switch (word.Substring(word.Length - 3))
			{
				//box--boxes 
				case "ses":
				case "zes":
				case "xes":
					{
						return true;
					}
			}
		}

		if (word.Length >= 3)
		{
			switch (word.Substring(word.Length - 2))
			{
				case "es":
					{
						return true;
					}
			}
		}

		if (word.Substring(word.Length - 1) != "s")
		{
			return false; // not a plural word if it doesn't end in S
		}

		return true;
	}

	#endregion
}
*/

#>
